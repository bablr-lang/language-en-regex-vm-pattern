/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#b8b1884da489877bbffd6722d41a244d00a0d1ce
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateArray as _interpolateArray, interpolateArrayChildren as _interpolateArrayChildren, interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
let _initProto, _FlagsDecs, _GroupDecs, _AssertionDecs, _StartOfInputAssertionDecs, _EndOfInputAssertionDecs, _WordBoundaryAssertionDecs, _GapDecs, _CharacterDecs, _CharacterClassDecs, _CharacterClassRangeDecs, _CharacterSetDecs, _AnyCharacterSetDecs, _DigitCharacterSetDecs, _SpaceCharacterSetDecs, _WordCharacterSetDecs, _QuantifierDecs, _EscapeSequenceDecs, _AnyDecs, _KeywordDecs, _PunctuatorDecs;
import { Node, CoveredBy, InjectFrom, Attributes, AllowEmpty } from '@bablr/helpers/decorators';
import objectEntries from 'iter-tools-es/methods/object-entries';
import * as Shared from '@bablr/helpers/productions';
import { buildString, buildBoolean, buildNumber, buildNullTag } from '@bablr/agast-vm-helpers';
export const canonicalURL = 'https://bablr.org/languages/core/en/bablr-regex-pattern';
export const dependencies = {};
const escapables = new Map(objectEntries({
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0'
}));
const flagCharacters = {
  global: 'g',
  ignoreCase: 'i',
  multiline: 'm',
  dotAll: 's',
  unicode: 'u',
  sticky: 'y'
};
const unique = flags => flags.length === new Set(flags).size;
const getSpecialPattern = span => {
  if (span === 'Pattern') {
    return _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
      alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
        elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
          elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("{")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("}")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("[")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\]")], {}, {
            cooked: "]"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("(")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit(")")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit(".")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("^")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("$")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("|")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
            cooked: "\n"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("<")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit(">")], {}, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
        }, {
          negate: false
        })]
      }, {})],
      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
    }, {});
  } else if (span === 'CharacterClass') {
    return _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
      openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
      alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
        elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
          elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\]")], {}, {
            cooked: "]"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
        }, {
          negate: false
        })]
      }, {})],
      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
    }, {});
  } else {
    throw new Error('unknown span type for special pattern');
  }
};
export const grammar = class RegexGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Pattern"], [_FlagsDecs, 2, "Flags"], [AllowEmpty, 2, "Alternatives"], [[AllowEmpty, Node], 2, "Alternative"], [AllowEmpty, 2, "Elements"], [_GroupDecs, 2, "Group"], [Node, 2, "CapturingGroup"], [_AssertionDecs, 2, "Assertion"], [_StartOfInputAssertionDecs, 2, "StartOfInputAssertion"], [_EndOfInputAssertionDecs, 2, "EndOfInputAssertion"], [_WordBoundaryAssertionDecs, 2, "WordBoundaryAssertion"], [_GapDecs, 2, "Gap"], [_CharacterDecs, 2, "Character"], [_CharacterClassDecs, 2, "CharacterClass"], [_CharacterClassRangeDecs, 2, "CharacterClassRange"], [_CharacterSetDecs, 2, "CharacterSet"], [_AnyCharacterSetDecs, 2, "AnyCharacterSet"], [_DigitCharacterSetDecs, 2, "DigitCharacterSet"], [_SpaceCharacterSetDecs, 2, "SpaceCharacterSet"], [_WordCharacterSetDecs, 2, "WordCharacterSet"], [_QuantifierDecs, 2, "Quantifier"], [Node, 2, "UnsignedInteger"], [_EscapeSequenceDecs, 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [Node, 2, "Digit"], [_AnyDecs, 2, "Any"], [_KeywordDecs, 2, "Keyword"], [_PunctuatorDecs, 2, "Punctuator"]], []).e;
  }
  constructor() {
    _initProto(this);
  }
  *[(_FlagsDecs = [Attributes(Object.keys(flagCharacters)), AllowEmpty, Node], _GroupDecs = [CoveredBy('Element'), Node], _AssertionDecs = CoveredBy('Element'), _StartOfInputAssertionDecs = [CoveredBy('Assertion'), Node], _EndOfInputAssertionDecs = [CoveredBy('Assertion'), Node], _WordBoundaryAssertionDecs = [Attributes(['negate']), CoveredBy('Assertion'), Node], _GapDecs = [CoveredBy('Assertion'), Node], _CharacterDecs = [CoveredBy('Element'), CoveredBy('CharacterClassElement'), Node], _CharacterClassDecs = [Attributes(['negate']), CoveredBy('Element'), Node], _CharacterClassRangeDecs = [CoveredBy('CharacterClassElement'), Node], _CharacterSetDecs = CoveredBy('Element'), _AnyCharacterSetDecs = [CoveredBy('CharacterSet'), Node], _DigitCharacterSetDecs = [Attributes(['negate']), CoveredBy('CharacterSet'), Node], _SpaceCharacterSetDecs = [Attributes(['negate']), CoveredBy('CharacterSet'), Node], _WordCharacterSetDecs = [Attributes(['negate']), CoveredBy('CharacterSet'), Node], _QuantifierDecs = [Attributes(['min', 'max']), Node], _EscapeSequenceDecs = [Attributes(['cooked']), Node], _AnyDecs = InjectFrom(Shared), _KeywordDecs = [Node, InjectFrom(Shared)], _PunctuatorDecs = [Node, InjectFrom(Shared)], "Pattern")]() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Pattern")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Flags"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Flags({
    ctx
  }) {
    const flags = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("g")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("i")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("m")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("y")], {}, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: false
              }),
              value: _t.s_i_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const flagsStr = ctx.sourceTextFor(flags) || '';
    if (flagsStr && !unique(flagsStr)) throw new Error('flags must be unique');
    for (const {
      0: name,
      1: chr
    } of Object.entries(flagCharacters)) {
      if (flagsStr.includes(chr)) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(buildString(name), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [..._interpolateArray(buildString(name)), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "true")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      } else {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(buildString(name), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [..._interpolateArray(buildString(name)), _t.node(_l.Instruction, "Boolean", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "false")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    }
    for (const flagChr of flagsStr) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
              intrinsicValue: buildString(flagChr),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("tokens[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Alternatives() {
    do {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Alternative"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("alternatives[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("|")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Alternative() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Elements"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Elements() {
    let matched = false;
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              negateToken: _t.s_i_node(_l.Regex, "Keyword", "^"),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("|")], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: true
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      matched = true;
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Element"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    if (!matched) yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Element() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "guard"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("?")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CharacterClass"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Group"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("(?:")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Assertion"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("$")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("^")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
                }, {})],
                separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
                  tokens: [_t.s_i_node(_l.Regex, "Keyword", "i")]
                }, {
                  global: false,
                  ignoreCase: true,
                  multiline: false,
                  dotAll: false,
                  unicode: false,
                  sticky: false
                })
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Gap"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                })), _t.lit("g")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CharacterSet"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`separators[]`, _t.arr(), _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\.")], {}, {
                    cooked: "."
                  }))], {}, {})]
                }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("p")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
                  tokens: [_t.s_i_node(_l.Regex, "Keyword", "i")]
                }, {
                  global: false,
                  ignoreCase: true,
                  multiline: false,
                  dotAll: false,
                  unicode: false,
                  sticky: false
                })
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`, _t.ref`expressionToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*"),
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Character"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("?")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("{")], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      return _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "holdForMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Quantifier"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Group() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("(?:")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CapturingGroup() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("(")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Assertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "StartOfInputAssertion"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "EndOfInputAssertion"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`, _t.ref`escapeToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*"),
                escapeToken: _t.s_i_node(_l.CSTML, "Punctuator", "@")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "WordBoundaryAssertion"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
                  tokens: [_t.s_i_node(_l.Regex, "Keyword", "i")]
                }, {
                  global: false,
                  ignoreCase: true,
                  multiline: false,
                  dotAll: false,
                  unicode: false,
                  sticky: false
                })
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *StartOfInputAssertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EndOfInputAssertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *WordBoundaryAssertion({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const m = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
                tokens: [_t.s_i_node(_l.Regex, "Keyword", "i")]
              }, {
                global: false,
                ignoreCase: true,
                multiline: false,
                dotAll: false,
                unicode: false,
                sticky: false
              })
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(m) === 'B'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(m) === 'B'))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Gap() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("g")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Character() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`escapeToken`], {
                escapeToken: _t.s_i_node(_l.CSTML, "Punctuator", "@")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "EscapeSequence"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`negateToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                negateToken: _t.s_i_node(_l.Regex, "Keyword", "^"),
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\r")], {}, {
                  cooked: "\r"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\n")], {}, {
                  cooked: "\n"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\t")], {}, {
                  cooked: "\t"
                }))], {}, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {
                negate: true
              })]
            }, {})],
            closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *CharacterClass() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancedSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("CharacterClass")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let neg = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negateToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(neg), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(neg))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
            tokens: [_t.s_i_node(_l.Regex, "Keyword", "s")]
          }, {
            global: false,
            ignoreCase: false,
            multiline: false,
            dotAll: true,
            unicode: false,
            sticky: false
          })
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CharacterClassElement"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balancer")
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CharacterClassElement() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CharacterSet"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`, _t.ref`flags`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("p")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                flags: _t.node(_l.Regex, "Flags", [_t.ref`tokens[]`, _t.arr(), _t.ref`tokens[]`], {
                  tokens: [_t.s_i_node(_l.Regex, "Keyword", "i")]
                }, {
                  global: false,
                  ignoreCase: true,
                  multiline: false,
                  dotAll: false,
                  unicode: false,
                  sticky: false
                })
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Gap"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                })), _t.lit("g")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`, _t.ref`expressionToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*"),
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Character"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      return _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "holdForMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "CharacterClassRange"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *CharacterClassRange() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`, _t.ref`expressionToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*"),
              expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Character"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`, _t.ref`expressionToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*"),
              expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Character"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CharacterSet() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Any"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
          sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`openToken`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit("  ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "AnyCharacterSet"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit("  ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "DigitCharacterSet"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("D")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit("  ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "SpaceCharacterSet"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("S")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit("  ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
                expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "WordCharacterSet"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                    cooked: "\\"
                  }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                    elements: [_t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("W")], {}, {})],
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                  }, {
                    negate: false
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *AnyCharacterSet() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *DigitCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("D")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'D'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'D'))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *SpaceCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("S")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'S'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'S'))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *WordCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escapeToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("W")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'W'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'W'))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Quantifier({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`expressionToken`], {
              expressionToken: _t.s_i_node(_l.CSTML, "Punctuator", "+")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Element"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("element")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let attrs, sigil;
    if (sigil = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("?")], {}, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {
                  negate: false
                })]
              }, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("sigilToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      switch (ctx.sourceTextFor(sigil)) {
        case '*':
          attrs = {
            min: 0,
            max: Infinity
          };
          break;
        case '+':
          attrs = {
            min: 1,
            max: Infinity
          };
          break;
        case '?':
          attrs = {
            min: 0,
            max: 1
          };
          break;
      }
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "balanced"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      let max;
      let min = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit(",")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("separator")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) {
        max = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
                  tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
                }, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
                selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
      min = min && ctx.sourceTextFor(min);
      max = max && ctx.sourceTextFor(max);
      min = min && parseInt(min, 10);
      max = max && parseInt(max, 10);
      attrs = {
        min,
        max
      };
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
                key: _t.s_node(_l.Spamex, "Identifier", "balancer")
              }, {})],
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(attrs.min ? buildNumber(attrs.min) : buildNullTag(), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(attrs.min ? buildNumber(attrs.min) : buildNullTag())],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(attrs.max ? buildNumber(attrs.max) : buildNullTag(), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(attrs.max ? buildNumber(attrs.max) : buildNullTag())],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *UnsignedInteger() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                value: _t.s_i_node(_l.Regex, "Keyword", "d")
              }, {}),
              value: _t.s_i_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EscapeSequence({
    state,
    ctx,
    value: props
  }) {
    const parentSpan = state.span;
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
              key: _t.s_node(_l.Spamex, "Identifier", "openSpan"),
              mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let match, cooked;
    if (match = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.Regex, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("0")], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
              intrinsicValue: buildString(match_),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
                mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                  closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = escapables.get(match_) || match_;
    } else if (match = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), ..._interpolateArrayChildren(getSpecialPattern(parentSpan, ctx.reifyExpression(props)), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(getSpecialPattern(parentSpan, ctx.reifyExpression(props)))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
              intrinsicValue: buildString(match_),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
                mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                  closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = ctx.sourceTextFor(match);
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`openToken`, _t.ref`elements[]`, _t.arr(), _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("x")], {}, {})],
              closeToken: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {
              negate: false
            })]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const codeNode = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.arr(), _t.ref`attributes[]`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "EscapeCode"),
              attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapToken`, _t.ref`value`], {
                key: _t.s_node(_l.Spamex, "Identifier", "closeSpan"),
                mapToken: _t.s_i_node(_l.Spamex, "Punctuator", "="),
                value: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                  closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
                }, {})
              }, {})],
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = parseInt(codeNode.properties.digits.map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildString(cooked), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.s_node(_l.Instruction, "Identifier", "cooked"), ..._interpolateArray(buildString(cooked))],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EscapeCode() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("type")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
              }, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
                closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
                selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
                  intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
                  tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
                }, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
                intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                  content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                  closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
                }, {}),
                selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      } else {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
              open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
                flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
                type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
                intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                  openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                  alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                    elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`openToken`, _t.ref`min`, _t.ref`closeToken`], {
                      element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                        escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                        value: _t.s_i_node(_l.Regex, "Keyword", "d")
                      }, {}),
                      openToken: _t.s_i_node(_l.Regex, "Punctuator", "{"),
                      min: _t.node(_l.Regex, "Number", [_t.lit("4")], {}, {}),
                      closeToken: _t.s_i_node(_l.Regex, "Punctuator", "}")
                    }, {
                      min: 4,
                      max: undefined,
                      greedy: true
                    })]
                  }, {})],
                  closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
                }, {}),
                selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
                closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
              }, {})
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
              sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`intrinsicToken`, _t.ref`tokenToken`], {
              intrinsicToken: _t.s_i_node(_l.CSTML, "Punctuator", "~"),
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("x")], {}, {}),
              closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("type")], {}, {}),
          closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("openToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
            open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
              openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              flags: _t.node(_l.CSTML, "Flags", [], {}, {}),
              type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
                openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`openToken`, _t.ref`min`, _t.ref`closeToken`], {
                    element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
                      escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                      value: _t.s_i_node(_l.Regex, "Keyword", "d")
                    }, {}),
                    openToken: _t.s_i_node(_l.Regex, "Punctuator", "{"),
                    min: _t.node(_l.Regex, "Number", [_t.lit("2")], {}, {}),
                    closeToken: _t.s_i_node(_l.Regex, "Punctuator", "}")
                  }, {
                    min: 2,
                    max: undefined,
                    greedy: true
                  })]
                }, {})],
                closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
              closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {})
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.embedded(_t.node(_l.Instruction, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`sigilToken`], {
            sigilToken: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`openToken`, _t.ref`content`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("closeToken")], {}, {}),
            closeToken: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Digits() {
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`], {
          open: _t.node(_l.Spamex, "OpenNodeMatcher", [_t.ref`openToken`, _t.ref`flags`, _t.ref`type`, _t.embedded(_t.node(_l.Spamex, "Space", [_t.lit(" ")], {}, {})), _t.ref`selfClosingTagToken`, _t.ref`closeToken`], {
            openToken: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            flags: _t.node(_l.CSTML, "Flags", [_t.ref`tokenToken`], {
              tokenToken: _t.s_i_node(_l.CSTML, "Punctuator", "*")
            }, {}),
            type: _t.s_node(_l.Spamex, "Identifier", "Digit"),
            selfClosingTagToken: _t.s_i_node(_l.Spamex, "Punctuator", "/"),
            closeToken: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Digit() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`openToken`, _t.ref`values[]`, _t.arr(), _t.ref`values[]`, _t.ref`closeToken`], {
        openToken: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`openToken`, _t.ref`alternatives[]`, _t.arr(), _t.ref`alternatives[]`, _t.ref`closeToken`], {
          openToken: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.arr(), _t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escapeToken`, _t.ref`value`], {
              escapeToken: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
              value: _t.s_i_node(_l.Regex, "Keyword", "d")
            }, {})]
          }, {})],
          closeToken: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        closeToken: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Any() {}
  *Keyword() {}
  *Punctuator() {}
};