/* @macrome
 * @generatedby @bablr/macrome-generator-bablr
 * @generatedfrom ./grammar.macro.js#a48c9e2aa0b0500c6443b40f6729cabf6adb922a
 * This file is autogenerated. Please do not edit it directly.
 * When editing run `npx macrome watch` then change the file this is generated from.
 */
import _applyDecs from "@babel/runtime/helpers/applyDecs2305";
import { interpolateString as _interpolateString } from "@bablr/agast-helpers/template";
import { interpolateArrayChildren as _interpolateArrayChildren } from "@bablr/agast-helpers/template";
import { interpolateArray as _interpolateArray } from "@bablr/agast-helpers/template";
import * as _l from "@bablr/agast-vm-helpers/languages";
import * as _t from "@bablr/agast-helpers/shorthand";
var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _initProto;
import { Node, CoveredBy, InjectFrom, Attributes, AllowEmpty } from '@bablr/helpers/decorators';
import objectEntries from 'iter-tools-es/methods/object-entries';
import * as Shared from '@bablr/helpers/productions';
import { buildString, buildBoolean, buildNumber, buildNull } from '@bablr/agast-vm-helpers';
export const canonicalURL = 'https://bablr.org/languages/core/bablr-regex-pattern';
export const dependencies = {};
const escapables = new Map(objectEntries({
  n: '\n',
  r: '\r',
  t: '\t',
  0: '\0'
}));
const flagCharacters = {
  global: 'g',
  ignoreCase: 'i',
  multiline: 'm',
  dotAll: 's',
  unicode: 'u',
  sticky: 'y'
};
const flagNames = Object.fromEntries(Object.entries(flagCharacters).map(([key, value]) => [value, key]));
const unique = flags => flags.length === new Set(flags).size;
const getSpecialPattern = span => {
  if (span === 'Pattern') {
    return _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
      open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
      alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
        elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "["),
          elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("{")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("}")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("[")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\]")], {}, {
            cooked: "]"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("(")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit(")")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit(".")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("^")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("$")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("|")], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\n")], {}, {
            cooked: "\n"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "]")
        }, {})]
      }, {})],
      close: _t.s_i_node(_l.Regex, "Punctuator", "/")
    }, {});
  } else if (span === 'CharacterClass') {
    return _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
      open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
      alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
        elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "["),
          elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\]")], {}, {
            cooked: "]"
          }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "]")
        }, {})]
      }, {})],
      close: _t.s_i_node(_l.Regex, "Punctuator", "/")
    }, {});
  } else {
    throw new Error('unknown span type for special pattern');
  }
};
export const grammar = (_dec = CoveredBy('Element'), _dec2 = CoveredBy('Element'), _dec3 = CoveredBy('Assertion'), _dec4 = CoveredBy('Assertion'), _dec5 = Attributes(['negate']), _dec6 = CoveredBy('Assertion'), _dec7 = CoveredBy('Element'), _dec8 = CoveredBy('CharacterClassElement'), _dec9 = CoveredBy('Element'), _dec10 = CoveredBy('CharacterClassElement'), _dec11 = CoveredBy('Element'), _dec12 = CoveredBy('CharacterSet'), _dec13 = Attributes(['negate']), _dec14 = CoveredBy('CharacterSet'), _dec15 = Attributes(['negate']), _dec16 = CoveredBy('CharacterSet'), _dec17 = Attributes(['negate']), _dec18 = CoveredBy('CharacterSet'), _dec19 = Attributes(['min', 'max']), _dec20 = Attributes(['cooked']), _dec21 = InjectFrom(Shared), _dec22 = InjectFrom(Shared), _dec23 = InjectFrom(Shared), class RegexGrammar {
  static {
    [_initProto] = _applyDecs(this, [[Node, 2, "Pattern"], [[AllowEmpty, Node], 2, "Flags"], [Node, 2, "Flag"], [AllowEmpty, 2, "Alternatives"], [[AllowEmpty, Node], 2, "Alternative"], [AllowEmpty, 2, "Elements"], [[_dec, Node], 2, "Group"], [Node, 2, "CapturingGroup"], [_dec2, 2, "Assertion"], [[_dec3, Node], 2, "StartOfInputAssertion"], [[_dec4, Node], 2, "EndOfInputAssertion"], [[_dec5, _dec6, Node], 2, "WordBoundaryAssertion"], [[_dec7, _dec8, Node], 2, "Character"], [[_dec9, Node], 2, "CharacterClass"], [[_dec10, Node], 2, "CharacterClassRange"], [_dec11, 2, "CharacterSet"], [[_dec12, Node], 2, "AnyCharacterSet"], [[_dec13, _dec14, Node], 2, "DigitCharacterSet"], [[_dec15, _dec16, Node], 2, "SpaceCharacterSet"], [[_dec17, _dec18, Node], 2, "WordCharacterSet"], [[_dec19, Node], 2, "Quantifier"], [Node, 2, "UnsignedInteger"], [[_dec20, Node], 2, "EscapeSequence"], [Node, 2, "EscapeCode"], [Node, 2, "Digit"], [_dec21, 2, "Any"], [[Node, _dec22], 2, "Keyword"], [[Node, _dec23], 2, "Punctuator"]], []).e;
  }
  constructor(...args) {
    _initProto(this);
  }
  *Pattern() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balanced")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancedSpan")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("Pattern")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("/")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancer")], {}, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Flags"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("flags")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Flags({
    ctx
  }) {
    const flags = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("g")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("i")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("m")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("y")], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {}),
              value: _t.s_i_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}) || '';
    const flagsStr = ctx.sourceTextFor(flags);
    for (const flag of ['global', 'ignoreCase', 'multiline', 'dotAll', 'unicode', 'sticky']) {
      if (!flags || !flagsStr.includes(flagCharacters[flag])) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildString(flag), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Instruction, "Null", [_t.ref`value`], {
              value: _t.s_i_node(_l.Instruction, "Keyword", "null")
            }, {}), ..._interpolateArray(buildString(flag))],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    }
    if (flags) {
      if (!unique(flagsStr)) throw new Error('flags must be unique');
      for (const flag of flagsStr) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildString(flagNames[flag]), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
              open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              type: _t.s_node(_l.Spamex, "Identifier", "Flag"),
              close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {}), ..._interpolateArray(buildString(flagNames[flag]))],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    }
  }
  *Flag() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("g")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("i")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("m")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("y")], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Alternatives() {
    do {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            type: _t.s_node(_l.Spamex, "Identifier", "Alternative"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("alternatives[]")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("|")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("separators[]")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Alternative() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Elements"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Elements() {
    let matched = false;
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`negate`, _t.ref`elements[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "["),
              negate: _t.s_i_node(_l.Regex, "Keyword", "^"),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("|")], {}, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      matched = true;
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "Element"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    if (!matched) yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Instruction, "Null", [_t.ref`value`], {
          value: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Element() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Any"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`value`], {
          value: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`open`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "CharacterClass"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "Group"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("(?:")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "Assertion"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("$")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("^")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
              }, {})],
              separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
                value: _t.s_i_node(_l.Regex, "Keyword", "i")
              }, {
                kind: "ignoreCase"
              })]
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "CharacterSet"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`separators[]`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\.")], {}, {
                  cooked: "."
                }))], {}, {})]
              }, {}), _t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("p")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {})],
              separators: [_t.s_i_node(_l.Regex, "Punctuator", "|")],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
                value: _t.s_i_node(_l.Regex, "Keyword", "i")
              }, {
                kind: "ignoreCase"
              })]
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "Character"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("*")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("+")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("?")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("{")], {}, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      return _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "holdForMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            type: _t.s_node(_l.Spamex, "Identifier", "Quantifier"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Group() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("(?:")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balanced")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancer")], {}, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CapturingGroup() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("(")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balanced")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Alternatives"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(")")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancer")], {}, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Assertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Any"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`value`], {
          value: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`open`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "StartOfInputAssertion"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "EndOfInputAssertion"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`escapeFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            escapeFlag: _t.s_i_node(_l.Spamex, "Punctuator", "@"),
            type: _t.s_node(_l.Spamex, "Identifier", "WordBoundaryAssertion"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
                value: _t.s_i_node(_l.Regex, "Keyword", "i")
              }, {
                kind: "ignoreCase"
              })]
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *StartOfInputAssertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EndOfInputAssertion() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("$")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *WordBoundaryAssertion({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    const m = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "Character", [_t.lit("b")], {}, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
              value: _t.s_i_node(_l.Regex, "Keyword", "i")
            }, {
              kind: "ignoreCase"
            })]
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(ctx.sourceTextFor(m) === 'B', _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(ctx.sourceTextFor(m) === 'B')],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Character() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
            cooked: "\\"
          }))], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`escapeFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            escapeFlag: _t.s_i_node(_l.Spamex, "Punctuator", "@"),
            type: _t.s_node(_l.Spamex, "Identifier", "EscapeSequence"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Instruction, "Null", [_t.ref`value`], {
            value: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`negate`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                negate: _t.s_i_node(_l.Regex, "Keyword", "^"),
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\r")], {}, {
                  cooked: "\r"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\n")], {}, {
                  cooked: "\n"
                }))], {}, {}), _t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\t")], {}, {
                  cooked: "\t"
                }))], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
              value: _t.s_i_node(_l.Regex, "Keyword", "s")
            }, {
              kind: "dotAll"
            })]
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *CharacterClass() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("[")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancedSpan")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("CharacterClass")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {}), _t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balanced")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("^")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "AnyCharacterSet", [_t.ref`value`], {
              value: _t.s_i_node(_l.Regex, "Keyword", ".")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
            value: _t.s_i_node(_l.Regex, "Keyword", "s")
          }, {
            kind: "dotAll"
          })]
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "CharacterClassElement"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("elements[]")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("]")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balancer")], {}, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CharacterClassElement() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Any"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`value`], {
          value: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`open`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n        ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "CharacterSet"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`, _t.ref`flags[]`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("p")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              flags: [_t.node(_l.Regex, "Flag", [_t.ref`value`], {
                value: _t.s_i_node(_l.Regex, "Keyword", "i")
              }, {
                kind: "ignoreCase"
              })]
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "Character"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      return _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "holdForMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "CharacterClassRange"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *CharacterClassRange() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
          type: _t.s_node(_l.Spamex, "Identifier", "Character"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("-")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("rangeOperator")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
          type: _t.s_node(_l.Spamex, "Identifier", "Character"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *CharacterSet() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          type: _t.s_node(_l.Spamex, "Identifier", "Any"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.Instruction, "Null", [_t.ref`value`], {
          value: _t.s_i_node(_l.Instruction, "Keyword", "null")
        }, {}), _t.node(_l.Instruction, "Array", [_t.ref`open`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n      ")], {}, {})), _t.ref`elements[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit("\n    ")], {}, {})), _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "["),
          elements: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "AnyCharacterSet"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "DigitCharacterSet"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("D")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "SpaceCharacterSet"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("S")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
            type: _t.s_node(_l.Spamex, "Identifier", "WordCharacterSet"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`, _t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                  cooked: "\\"
                }))], {}, {}), _t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                  open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                  elements: [_t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("W")], {}, {})],
                  close: _t.s_i_node(_l.Regex, "Punctuator", "]")
                }, {})]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", "]")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *AnyCharacterSet() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit(".")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *DigitCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("d")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("D")], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'D'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'D'))],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *SpaceCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("s")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("S")], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'S'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'S'))],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *WordCharacterSet({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let code = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
            alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
              elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "["),
                elements: [_t.node(_l.Regex, "Character", [_t.lit("w")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("W")], {}, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "]")
              }, {})]
            }, {})],
            close: _t.s_i_node(_l.Regex, "Punctuator", "/")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildBoolean(ctx.sourceTextFor(code) === 'W'), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("negate")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(buildBoolean(ctx.sourceTextFor(code) === 'W'))],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Quantifier({
    ctx
  }) {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`expressionFlag`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          expressionFlag: _t.s_i_node(_l.Spamex, "Punctuator", "+"),
          type: _t.s_node(_l.Spamex, "Identifier", "Element"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("element")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let attrs;
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("*")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      attrs = {
        min: 0,
        max: Infinity
      };
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("+")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      attrs = {
        min: 1,
        max: Infinity
      };
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("?")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      attrs = {
        min: 0,
        max: 1
      };
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("balanced")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      let max;
      let min = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit(",")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("separator")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) {
        max = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.ref`close`], {
              open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
              type: _t.s_node(_l.Spamex, "Identifier", "UnsignedInteger"),
              close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
      min = min && ctx.sourceTextFor(min);
      max = max && ctx.sourceTextFor(max);
      min = min && parseInt(min, 10);
      max = max && parseInt(max, 10);
      attrs = {
        min,
        max
      };
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            attributes: [_t.node(_l.Spamex, "BooleanAttribute", [_t.ref`key`], {
              key: _t.node(_l.Spamex, "Literal", [_t.lit("balancer")], {}, {})
            }, {})],
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(attrs.min ? buildNumber(attrs.min) : buildNull(), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("min")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(attrs.min ? buildNumber(attrs.min) : buildNull())],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(attrs.max ? buildNumber(attrs.max) : buildNull(), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("max")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {}), ..._interpolateArray(attrs.max ? buildNumber(attrs.max) : buildNull())],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *UnsignedInteger() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`value`], {
              element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escape`, _t.ref`value`], {
                escape: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                value: _t.s_i_node(_l.Regex, "Keyword", "d")
              }, {}),
              value: _t.s_i_node(_l.Regex, "Keyword", "+")
            }, {
              min: 1,
              max: Infinity,
              greedy: true
            })]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EscapeSequence({
    state,
    ctx,
    value: props
  }) {
    const parentSpan = state.span;
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
              cooked: "\\"
            }))], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
            key: _t.node(_l.Spamex, "Literal", [_t.lit("openSpan")], {}, {}),
            mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
            value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})
          }, {})],
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("escape")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
    let match, cooked;
    if (match = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.embedded(_t.s_e_node(_l.CSTML, "Escape", [_t.lit("\\\\")], {}, {
                cooked: "\\"
              }))], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("/")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("n")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("r")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("t")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("0")], {}, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: buildString(match_),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
              key: _t.node(_l.Spamex, "Literal", [_t.lit("closeSpan")], {}, {}),
              mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
                open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = escapables.get(match_) || match_;
    } else if (match = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, ..._interpolateArrayChildren(getSpecialPattern(parentSpan, ctx.reifyExpression(props)), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [..._interpolateArray(getSpecialPattern(parentSpan, ctx.reifyExpression(props)))],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const match_ = ctx.sourceTextFor(match);
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
            intrinsicValue: buildString(match_),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
              key: _t.node(_l.Spamex, "Literal", [_t.lit("closeSpan")], {}, {}),
              mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
                open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = ctx.sourceTextFor(match);
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "match"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "CharacterClass", [_t.ref`open`, _t.ref`elements[]`, _t.ref`elements[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "["),
              elements: [_t.node(_l.Regex, "Character", [_t.lit("u")], {}, {}), _t.node(_l.Regex, "Character", [_t.lit("x")], {}, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "]")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      const codeNode = yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`attributes[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            type: _t.s_node(_l.Spamex, "Identifier", "EscapeCode"),
            attributes: [_t.node(_l.Spamex, "MappingAttribute", [_t.ref`key`, _t.ref`mapOperator`, _t.ref`value`], {
              key: _t.node(_l.Spamex, "Literal", [_t.lit("closeSpan")], {}, {}),
              mapOperator: _t.s_i_node(_l.Spamex, "Punctuator", "="),
              value: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
                open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("Escape")], {}, {}),
                close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {})
            }, {})],
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      cooked = parseInt(ctx.getProperty(codeNode, 'digits').map(digit => ctx.sourceTextFor(digit)).join(''), 16);
    } else {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "fail"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "bindAttribute"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), ..._interpolateArrayChildren(buildString(cooked), _t.ref`values[]`, _t.embedded(_t.t_node(_l.Comment, null, [_t.embedded(_t.t_node('Space', 'Space', [_t.lit(' ')]))]))), _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.s_node(_l.Instruction, "Identifier", "cooked"), ..._interpolateArray(buildString(cooked))],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *EscapeCode() {
    if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("u")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("type")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
            type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
            intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("{")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {})) {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.ref`close`], {
              open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
              close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
              open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
              type: _t.s_node(_l.Spamex, "Identifier", "Punctuator"),
              intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
                open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
                content: _t.node(_l.CSTML, "Content", [_t.lit("}")], {}, {}),
                close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
              }, {}),
              close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      } else {
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
              open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
              type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
              intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
                open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
                alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
                  elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`open`, _t.ref`min`, _t.ref`close`], {
                    element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escape`, _t.ref`value`], {
                      escape: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                      value: _t.s_i_node(_l.Regex, "Keyword", "d")
                    }, {}),
                    open: _t.s_i_node(_l.Regex, "Punctuator", "{"),
                    min: _t.node(_l.Regex, "Number", [_t.lit("4")], {}, {}),
                    close: _t.s_i_node(_l.Regex, "Punctuator", "}")
                  }, {
                    min: 4,
                    max: undefined,
                    greedy: true
                  })]
                }, {})],
                close: _t.s_i_node(_l.Regex, "Punctuator", "/")
              }, {}),
              close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
        yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
          verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
          arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
            open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
            values: [_t.node(_l.Instruction, "Null", [_t.ref`value`], {
              value: _t.s_i_node(_l.Instruction, "Keyword", "null")
            }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
              open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
              content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
              close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
            }, {})],
            close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
          }, {})
        }, {});
      }
    } else if (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Keyword"),
          intrinsicValue: _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("x")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {}),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
          open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
          content: _t.node(_l.CSTML, "Content", [_t.lit("type")], {}, {}),
          close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {})) {
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`value`], {
            value: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("open")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`type`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`intrinsicValue`, _t.ref`close`], {
            open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
            type: _t.s_node(_l.Spamex, "Identifier", "Digits"),
            intrinsicValue: _t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
              open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
              alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
                elements: [_t.node(_l.Regex, "Quantifier", [_t.ref`element`, _t.ref`open`, _t.ref`min`, _t.ref`close`], {
                  element: _t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escape`, _t.ref`value`], {
                    escape: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
                    value: _t.s_i_node(_l.Regex, "Keyword", "d")
                  }, {}),
                  open: _t.s_i_node(_l.Regex, "Punctuator", "{"),
                  min: _t.node(_l.Regex, "Number", [_t.lit("2")], {}, {}),
                  close: _t.s_i_node(_l.Regex, "Punctuator", "}")
                }, {
                  min: 2,
                  max: undefined,
                  greedy: true
                })]
              }, {})],
              close: _t.s_i_node(_l.Regex, "Punctuator", "/")
            }, {}),
            close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("value")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
      yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
        verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
        arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.embedded(_t.s_t_node(_l.Space, "Space", [_t.lit(" ")], {}, {})), _t.ref`values[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
          values: [_t.node(_l.Instruction, "Null", [_t.ref`value`], {
            value: _t.s_i_node(_l.Instruction, "Keyword", "null")
          }, {}), _t.node(_l.CSTML, "String", [_t.ref`open`, _t.ref`content`, _t.ref`close`], {
            open: _t.s_i_node(_l.CSTML, "Punctuator", "'"),
            content: _t.node(_l.CSTML, "Content", [_t.lit("close")], {}, {}),
            close: _t.s_i_node(_l.CSTML, "Punctuator", "'")
          }, {})],
          close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
        }, {})
      }, {});
    }
  }
  *Digits() {
    while (yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eatMatch"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Spamex, "NodeMatcher", [_t.ref`open`, _t.ref`tokenFlag`, _t.ref`type`, _t.ref`close`], {
          open: _t.s_i_node(_l.Spamex, "Punctuator", "<"),
          tokenFlag: _t.s_i_node(_l.Spamex, "Punctuator", "*"),
          type: _t.s_node(_l.Spamex, "Identifier", "Digit"),
          close: _t.s_i_node(_l.Spamex, "Punctuator", ">")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {}));
  }
  *Digit() {
    yield _t.node(_l.Instruction, "Call", [_t.ref`verb`, _t.ref`arguments`], {
      verb: _t.s_node(_l.Instruction, "Identifier", "eat"),
      arguments: _t.node(_l.Instruction, "Tuple", [_t.ref`open`, _t.ref`values[]`, _t.ref`close`], {
        open: _t.s_i_node(_l.Instruction, "Punctuator", "("),
        values: [_t.node(_l.Regex, "Pattern", [_t.ref`open`, _t.ref`alternatives[]`, _t.ref`close`], {
          open: _t.s_i_node(_l.Regex, "Punctuator", "/"),
          alternatives: [_t.node(_l.Regex, "Alternative", [_t.ref`elements[]`], {
            elements: [_t.node(_l.Regex, "DigitCharacterSet", [_t.ref`escape`, _t.ref`value`], {
              escape: _t.s_i_node(_l.Regex, "Punctuator", "\\"),
              value: _t.s_i_node(_l.Regex, "Keyword", "d")
            }, {})]
          }, {})],
          close: _t.s_i_node(_l.Regex, "Punctuator", "/")
        }, {})],
        close: _t.s_i_node(_l.Instruction, "Punctuator", ")")
      }, {})
    }, {});
  }
  *Any() {}
  *Keyword() {}
  *Punctuator() {}
});